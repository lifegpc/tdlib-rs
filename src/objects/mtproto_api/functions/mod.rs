use super::types::P_Q_inner_data;
use crate::objects::traits::{Serialize, TypeId};
use bytes::BytesMut;
use openssl::{pkey::Public, rsa::Rsa};
use rand::{Rng, SeedableRng};

#[derive(Clone, Debug, tdlib_rs_impl::Serialize)]
/// The first step to [DH exchange initiation](https://core.telegram.org/mtproto/auth_key#dh-exchange-initiation)
///
/// Origin: `req_pq_multi#be7e8ef1 nonce:int128 = ResPQ;`
pub struct req_pq_multi {
    /// Selected randomly by the client (random number) and identifies the client within this communication
    pub nonce: i128,
}

impl req_pq_multi {
    /// Create a new instance.
    pub fn new() -> Self {
        Self {
            nonce: rand::rngs::StdRng::from_entropy().gen(),
        }
    }
}

impl TypeId for req_pq_multi {
    fn type_id2() -> u32 {
        0xbe7e8ef1
    }
}

#[derive(Clone, Debug, tdlib_rs_impl::Serialize)]
/// Used to start Diffie-Hellman key exchange. [More](https://core.telegram.org/mtproto/auth_key#presenting-proof-of-work-server-authentication)
///
/// Origin: `req_DH_params#d712e4be nonce:int128 server_nonce:int128 p:string q:string public_key_fingerprint:long encrypted_data:string = Server_DH_Params;`
pub struct req_DH_params {
    /// Value generated by client in [Step 1](https://core.telegram.org/mtproto/auth_key#dh-exchange-initiation).
    pub nonce: i128,
    /// Value received from server in [Step 2](https://core.telegram.org/mtproto/auth_key#dh-exchange-initiation).
    pub server_nonce: i128,
    /// First prime cofactor.
    pub p: BytesMut,
    /// Second prime cofactor.
    pub q: BytesMut,
    /// Public key fingerprint.
    pub public_key_fingerprint: i64,
    /// Encrypted data.
    pub encrypted_data: BytesMut,
}

impl req_DH_params {
    /// Create a new instance.
    /// * `p_q_inner_data` - Inner data
    /// * `public_key_fingerprint` - The fingerprint of the server public key
    /// * `server_public_key` - Server public key
    pub fn new(
        p_q_inner_data: &P_Q_inner_data,
        public_key_fingerprint: i64,
        server_public_key: &Rsa<Public>,
    ) -> Result<Self, crate::aes::EncryptError> {
        let nonce = match p_q_inner_data {
            P_Q_inner_data::P_Q_inner_data_dc(v) => v.nonce,
            P_Q_inner_data::P_Q_inner_data_temp_dc(v) => v.nonce,
        };
        let server_nonce = match p_q_inner_data {
            P_Q_inner_data::P_Q_inner_data_dc(v) => v.server_nonce,
            P_Q_inner_data::P_Q_inner_data_temp_dc(v) => v.server_nonce,
        };
        let p = match p_q_inner_data {
            P_Q_inner_data::P_Q_inner_data_dc(v) => v.p.clone(),
            P_Q_inner_data::P_Q_inner_data_temp_dc(v) => v.p.clone(),
        };
        let q = match p_q_inner_data {
            P_Q_inner_data::P_Q_inner_data_dc(v) => v.q.clone(),
            P_Q_inner_data::P_Q_inner_data_temp_dc(v) => v.q.clone(),
        };
        let raw_data = p_q_inner_data.serialize_to_bytes();
        let encrypted_data = crate::aes::rsa_pad(&raw_data, server_public_key)?;
        Ok(Self {
            nonce,
            server_nonce,
            p,
            q,
            public_key_fingerprint,
            encrypted_data,
        })
    }
}

impl TypeId for req_DH_params {
    fn type_id2() -> u32 {
        0xd712e4be
    }
}
